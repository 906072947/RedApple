宏的设计是考虑方便替换的原则, 而且需要多次替换
而宏的添加必须添加新的宏解析语法, 以及更多的一元运算符, 例如'`', ',', '@' 等

defmacro class(name, father, list) {
	struct @name {
		,@list
		class_meta p_this;
		@if_func(father p_super;)
	}
}

deffunc if_func(a, b)

@表示 后面接的是一个宏表达式， ‘,@’ 则表示将该表达式展开并填入到该位置

另外一种编译时函数, 则是在用脚本的形式, 定义了翻译时的宏替换函数, 这个宏函数通过执行lua代码, 可以实现编译时的特殊功能, 甚至能够控制增加翻译趟数, 修改每一次翻译用的宏。

由于有了lua的扩展性，我们支持在程序内定义宏，实现简单的替换和展开，支持使用lua宏和lua函数，进行编译时的翻译扩展。更支持C++的宏扩展，提供最全的底层支持。

简化设计的考虑，不再自己实现脚本引擎，而全交由lua扩展实现。